{"ast":null,"code":"import _toConsumableArray from\"/Users/claudia.crisostomo/Documents/elvisp/lokalise-challenge/romaer-app-2/roamer-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import{addProjectAction,addLanguagesAction,removeTranslationAction}from'./app/actions';import{newProjectInitialState}from'./initialState';/**\r\n * This function can be used in the future to create a project on the api\r\n * Then, according with result of http request, the data can be\r\n * stored as sucessfully or failed.\r\n * In this context, there's no failer flow, therefore, this function\r\n * trigger the action addProjectAction to add a new project\r\n */export var createProject=function createProject(){return function(dispatch){dispatch(addProjectAction(newProjectInitialState));return Promise.resolve();};};/**\r\n * This function can be used in the future to save the data on api\r\n * Then, according with result of http request, the data can be\r\n * stored as sucessfully or failed.\r\n * In this context, there's no failer flow, therefore, this function\r\n * trigger the action addLanguagesAction to add the languages to a\r\n * specific project id\r\n * @param projectId\r\n * @param languages\r\n */export var addLanguages=function addLanguages(project,languages){return function(dispatch){var translationSections=project.translationSections.slice();var lastId=translationSections.length>0?translationSections[translationSections.length-1].id:0;translationSections.push.apply(translationSections,_toConsumableArray(languages.map(function(language){return{id:++lastId,country:language.value,language:language.label,done:0,wordsToDo:40000,unverified:0};})));dispatch(addLanguagesAction(project.id,translationSections));return Promise.resolve();};};/**\r\n * This function can be used in the future to make an http request\r\n * with delete method.\r\n * Then, according with result of http request, the data can be\r\n * stored as sucessfully or failed.\r\n * In this context, there's no failer flow, therefore, this function\r\n * trigger the action removeTranslationAction to remove the translation to a\r\n * specific project id\r\n * @param projectId\r\n * @param translationId\r\n */export var removeTranslation=function removeTranslation(projectId,translationId){return function(dispatch){dispatch(removeTranslationAction(projectId,translationId));return Promise.resolve();};};","map":{"version":3,"sources":["/Users/claudia.crisostomo/Documents/elvisp/lokalise-challenge/romaer-app-2/roamer-app/src/redux/fetch.ts"],"names":["addProjectAction","addLanguagesAction","removeTranslationAction","newProjectInitialState","createProject","dispatch","Promise","resolve","addLanguages","project","languages","translationSections","slice","lastId","length","id","push","map","language","country","value","label","done","wordsToDo","unverified","removeTranslation","projectId","translationId"],"mappings":"oNACA,OAASA,gBAAT,CAA2BC,kBAA3B,CAA+CC,uBAA/C,KAA8E,eAA9E,CACA,OAASC,sBAAT,KAAuC,gBAAvC,CAGA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,IAAMC,CAAAA,aAAa,CAAG,QAAhBA,CAAAA,aAAgB,EAAkD,CAC3E,MAAO,UAAAC,QAAQ,CAAI,CACfA,QAAQ,CAACL,gBAAgB,CAACG,sBAAD,CAAjB,CAAR,CACA,MAAOG,CAAAA,OAAO,CAACC,OAAR,EAAP,CACH,CAHD,CAIH,CALM,CAOP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,IAAMC,CAAAA,YAAY,CAAG,QAAfA,CAAAA,YAAe,CAACC,OAAD,CAAwBC,SAAxB,CAAmG,CAC3H,MAAO,UAAAL,QAAQ,CAAI,CACf,GAAMM,CAAAA,mBAAmB,CAAGF,OAAO,CAACE,mBAAR,CAA4BC,KAA5B,EAA5B,CACA,GAAIC,CAAAA,MAAM,CAAGF,mBAAmB,CAACG,MAApB,CAA6B,CAA7B,CAAiCH,mBAAmB,CAACA,mBAAmB,CAACG,MAApB,CAA6B,CAA9B,CAAnB,CAAoDC,EAArF,CAA0F,CAAvG,CACAJ,mBAAmB,CAACK,IAApB,OAAAL,mBAAmB,oBAASD,SAAS,CAACO,GAAV,CAAc,SAAAC,QAAQ,CAAI,CAClD,MAAO,CACHH,EAAE,CAAE,EAAEF,MADH,CAEHM,OAAO,CAAED,QAAQ,CAACE,KAFf,CAGHF,QAAQ,CAAEA,QAAQ,CAACG,KAHhB,CAIHC,IAAI,CAAE,CAJH,CAKHC,SAAS,CAAE,KALR,CAMHC,UAAU,CAAE,CANT,CAAP,CAQH,CAT2B,CAAT,EAAnB,CAUAnB,QAAQ,CAACJ,kBAAkB,CAACQ,OAAO,CAACM,EAAT,CAAaJ,mBAAb,CAAnB,CAAR,CACA,MAAOL,CAAAA,OAAO,CAACC,OAAR,EAAP,CACH,CAfD,CAgBH,CAjBM,CAmBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,IAAMkB,CAAAA,iBAAiB,CAAG,QAApBA,CAAAA,iBAAoB,CAACC,SAAD,CAAoBC,aAApB,CAA0F,CACvH,MAAO,UAAAtB,QAAQ,CAAI,CACfA,QAAQ,CAACH,uBAAuB,CAACwB,SAAD,CAAYC,aAAZ,CAAxB,CAAR,CACA,MAAOrB,CAAAA,OAAO,CAACC,OAAR,EAAP,CACH,CAHD,CAIH,CALM","sourcesContent":["import { AppDispatch } from './store';\r\nimport { addProjectAction, addLanguagesAction, removeTranslationAction } from './app/actions';\r\nimport { newProjectInitialState } from './initialState';\r\nimport { LanguageState, ProjectState } from './appState';\r\n\r\n/**\r\n * This function can be used in the future to create a project on the api\r\n * Then, according with result of http request, the data can be\r\n * stored as sucessfully or failed.\r\n * In this context, there's no failer flow, therefore, this function\r\n * trigger the action addProjectAction to add a new project\r\n */\r\nexport const createProject = (): ((dispatch: AppDispatch) => Promise<void>) => {\r\n    return dispatch => {\r\n        dispatch(addProjectAction(newProjectInitialState));\r\n        return Promise.resolve();\r\n    };\r\n};\r\n\r\n/**\r\n * This function can be used in the future to save the data on api\r\n * Then, according with result of http request, the data can be\r\n * stored as sucessfully or failed.\r\n * In this context, there's no failer flow, therefore, this function\r\n * trigger the action addLanguagesAction to add the languages to a\r\n * specific project id\r\n * @param projectId\r\n * @param languages\r\n */\r\nexport const addLanguages = (project: ProjectState, languages: LanguageState[]): ((dispatch: AppDispatch) => Promise<void>) => {\r\n    return dispatch => {\r\n        const translationSections = project.translationSections.slice();\r\n        let lastId = translationSections.length > 0 ? translationSections[translationSections.length - 1].id : 0;\r\n        translationSections.push(...languages.map(language => {\r\n            return {\r\n                id: ++lastId,\r\n                country: language.value,\r\n                language: language.label,\r\n                done: 0,\r\n                wordsToDo: 40000,\r\n                unverified: 0,\r\n            };\r\n        }));\r\n        dispatch(addLanguagesAction(project.id, translationSections));\r\n        return Promise.resolve();\r\n    };\r\n};\r\n\r\n/**\r\n * This function can be used in the future to make an http request\r\n * with delete method.\r\n * Then, according with result of http request, the data can be\r\n * stored as sucessfully or failed.\r\n * In this context, there's no failer flow, therefore, this function\r\n * trigger the action removeTranslationAction to remove the translation to a\r\n * specific project id\r\n * @param projectId\r\n * @param translationId\r\n */\r\nexport const removeTranslation = (projectId: number, translationId: number): ((dispatch: AppDispatch) => Promise<void>) => {\r\n    return dispatch => {\r\n        dispatch(removeTranslationAction(projectId, translationId));\r\n        return Promise.resolve();\r\n    };\r\n};\r\n"]},"metadata":{},"sourceType":"module"}