{"ast":null,"code":"import { addProjectAction, addLanguagesAction, removeTranslationAction } from './app/actions';\nimport { newProjectInitialState } from './initialState';\nimport _ from 'lodash';\n/**\r\n * This function can be used in the future to create a project on the api\r\n * Then, according with result of http request, the data can be\r\n * stored as sucessfully or failed.\r\n * In this context, there's no failer flow, therefore, this function\r\n * trigger the action addProjectAction to add a new project\r\n */\n\nexport const createProject = () => {\n  return dispatch => {\n    dispatch(addProjectAction(newProjectInitialState));\n    return Promise.resolve();\n  };\n};\n/**\r\n * This function can be used in the future to save the data on api\r\n * Then, according with result of http request, the data can be\r\n * stored as sucessfully or failed.\r\n * In this context, there's no failer flow, therefore, this function\r\n * trigger the action addLanguagesAction to add the languages to a\r\n * specific project id\r\n * @param projectId\r\n * @param languages\r\n */\n\nexport const addLanguages = (project, languages) => {\n  return dispatch => {\n    const translationSections = project.translationSections.slice();\n    let lastId = translationSections.length > 0 ? translationSections[translationSections.length - 1].id : 0;\n    translationSections.push(...languages.map(language => {\n      return {\n        id: ++lastId,\n        country: language.value,\n        language: language.label,\n        done: 0,\n        wordsToDo: 40000,\n        unverified: 0\n      };\n    }));\n    dispatch(addLanguagesAction(project.id, translationSections));\n    return Promise.resolve();\n  };\n};\n/**\r\n * This function can be used in the future to make an http request\r\n * with delete method.\r\n * Then, according with result of http request, the data can be\r\n * stored as sucessfully or failed.\r\n * In this context, there's no failer flow, therefore, this function\r\n * trigger the action removeTranslationAction to remove the translation to a\r\n * specific project id\r\n * @param projectId\r\n * @param translationId\r\n */\n\nexport const removeTranslation = (project, translations, translationToBeDeleted) => {\n  return dispatch => {\n    let translationSections = _.cloneDeep(translations);\n\n    translationSections = translationSections.filter(translation => translation.id !== translationToBeDeleted.id);\n    dispatch(removeTranslationAction(project.id, translationToBeDeleted.id));\n    return Promise.resolve();\n  };\n};","map":{"version":3,"sources":["/Users/claudia.crisostomo/Documents/elvisp/lokalise-challenge/romaer-app-2/roamer-app/src/redux/fetch.ts"],"names":["addProjectAction","addLanguagesAction","removeTranslationAction","newProjectInitialState","_","createProject","dispatch","Promise","resolve","addLanguages","project","languages","translationSections","slice","lastId","length","id","push","map","language","country","value","label","done","wordsToDo","unverified","removeTranslation","translations","translationToBeDeleted","cloneDeep","filter","translation"],"mappings":"AACA,SAASA,gBAAT,EAA2BC,kBAA3B,EAA+CC,uBAA/C,QAA8E,eAA9E;AACA,SAASC,sBAAT,QAAuC,gBAAvC;AAEA,OAAOC,CAAP,MAAc,QAAd;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,aAAa,GAAG,MAAkD;AAC3E,SAAOC,QAAQ,IAAI;AACfA,IAAAA,QAAQ,CAACN,gBAAgB,CAACG,sBAAD,CAAjB,CAAR;AACA,WAAOI,OAAO,CAACC,OAAR,EAAP;AACH,GAHD;AAIH,CALM;AAOP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,YAAY,GAAG,CAACC,OAAD,EAAwBC,SAAxB,KAAmG;AAC3H,SAAOL,QAAQ,IAAI;AACf,UAAMM,mBAAmB,GAAGF,OAAO,CAACE,mBAAR,CAA4BC,KAA5B,EAA5B;AACA,QAAIC,MAAM,GAAGF,mBAAmB,CAACG,MAApB,GAA6B,CAA7B,GAAiCH,mBAAmB,CAACA,mBAAmB,CAACG,MAApB,GAA6B,CAA9B,CAAnB,CAAoDC,EAArF,GAA0F,CAAvG;AACAJ,IAAAA,mBAAmB,CAACK,IAApB,CAAyB,GAAGN,SAAS,CAACO,GAAV,CAAcC,QAAQ,IAAI;AAClD,aAAO;AACHH,QAAAA,EAAE,EAAE,EAAEF,MADH;AAEHM,QAAAA,OAAO,EAAED,QAAQ,CAACE,KAFf;AAGHF,QAAAA,QAAQ,EAAEA,QAAQ,CAACG,KAHhB;AAIHC,QAAAA,IAAI,EAAE,CAJH;AAKHC,QAAAA,SAAS,EAAE,KALR;AAMHC,QAAAA,UAAU,EAAE;AANT,OAAP;AAQH,KAT2B,CAA5B;AAUAnB,IAAAA,QAAQ,CAACL,kBAAkB,CAACS,OAAO,CAACM,EAAT,EAAaJ,mBAAb,CAAnB,CAAR;AACA,WAAOL,OAAO,CAACC,OAAR,EAAP;AACH,GAfD;AAgBH,CAjBM;AAmBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMkB,iBAAiB,GAAG,CAAChB,OAAD,EAAwBiB,YAAxB,EAA0DC,sBAA1D,KAAmJ;AAChL,SAAOtB,QAAQ,IAAI;AACf,QAAIM,mBAAmB,GAAGR,CAAC,CAACyB,SAAF,CAAYF,YAAZ,CAA1B;;AACAf,IAAAA,mBAAmB,GAAGA,mBAAmB,CAACkB,MAApB,CAA2BC,WAAW,IAAIA,WAAW,CAACf,EAAZ,KAAmBY,sBAAsB,CAACZ,EAApF,CAAtB;AACAV,IAAAA,QAAQ,CAACJ,uBAAuB,CAACQ,OAAO,CAACM,EAAT,EAAaY,sBAAsB,CAACZ,EAApC,CAAxB,CAAR;AACA,WAAOT,OAAO,CAACC,OAAR,EAAP;AACH,GALD;AAMH,CAPM","sourcesContent":["import { AppDispatch } from './store';\r\nimport { addProjectAction, addLanguagesAction, removeTranslationAction } from './app/actions';\r\nimport { newProjectInitialState } from './initialState';\r\nimport { LanguageState, ProjectState, TranslationState } from './appState';\r\nimport _ from 'lodash';\r\n\r\n/**\r\n * This function can be used in the future to create a project on the api\r\n * Then, according with result of http request, the data can be\r\n * stored as sucessfully or failed.\r\n * In this context, there's no failer flow, therefore, this function\r\n * trigger the action addProjectAction to add a new project\r\n */\r\nexport const createProject = (): ((dispatch: AppDispatch) => Promise<void>) => {\r\n    return dispatch => {\r\n        dispatch(addProjectAction(newProjectInitialState));\r\n        return Promise.resolve();\r\n    };\r\n};\r\n\r\n/**\r\n * This function can be used in the future to save the data on api\r\n * Then, according with result of http request, the data can be\r\n * stored as sucessfully or failed.\r\n * In this context, there's no failer flow, therefore, this function\r\n * trigger the action addLanguagesAction to add the languages to a\r\n * specific project id\r\n * @param projectId\r\n * @param languages\r\n */\r\nexport const addLanguages = (project: ProjectState, languages: LanguageState[]): ((dispatch: AppDispatch) => Promise<void>) => {\r\n    return dispatch => {\r\n        const translationSections = project.translationSections.slice();\r\n        let lastId = translationSections.length > 0 ? translationSections[translationSections.length - 1].id : 0;\r\n        translationSections.push(...languages.map(language => {\r\n            return {\r\n                id: ++lastId,\r\n                country: language.value,\r\n                language: language.label,\r\n                done: 0,\r\n                wordsToDo: 40000,\r\n                unverified: 0,\r\n            };\r\n        }));\r\n        dispatch(addLanguagesAction(project.id, translationSections));\r\n        return Promise.resolve();\r\n    };\r\n};\r\n\r\n/**\r\n * This function can be used in the future to make an http request\r\n * with delete method.\r\n * Then, according with result of http request, the data can be\r\n * stored as sucessfully or failed.\r\n * In this context, there's no failer flow, therefore, this function\r\n * trigger the action removeTranslationAction to remove the translation to a\r\n * specific project id\r\n * @param projectId\r\n * @param translationId\r\n */\r\nexport const removeTranslation = (project: ProjectState, translations: TranslationState[], translationToBeDeleted: TranslationState): ((dispatch: AppDispatch) => Promise<void>) => {\r\n    return dispatch => {\r\n        let translationSections = _.cloneDeep(translations);\r\n        translationSections = translationSections.filter(translation => translation.id !== translationToBeDeleted.id);\r\n        dispatch(removeTranslationAction(project.id, translationToBeDeleted.id));\r\n        return Promise.resolve();\r\n    };\r\n};\r\n"]},"metadata":{},"sourceType":"module"}